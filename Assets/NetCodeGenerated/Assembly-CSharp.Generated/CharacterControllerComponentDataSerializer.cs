//THIS FILE IS AUTOGENERATED BY GHOSTCOMPILER. DON'T MODIFY OR ALTER.
using System;
using AOT;
using Unity.Burst;
using Unity.Networking.Transport;
using Unity.NetCode.LowLevel.Unsafe;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Entities;
using Unity.Collections;
using Unity.NetCode;
using Unity.Transforms;
using Unity.Mathematics;

namespace Assembly_CSharp.Generated
{
    [BurstCompile]
    public struct CharacterControllerComponentDataGhostComponentSerializer
    {
        static GhostComponentSerializer.State GetState()
        {
            // This needs to be lazy initialized because otherwise there is a depenency on the static initialization order which breaks il2cpp builds due to TYpeManager not being initialized yet
            if (!s_StateInitialized)
            {
                s_State = new GhostComponentSerializer.State
                {
                    GhostFieldsHash = 17375489658407481695,
                    ExcludeFromComponentCollectionHash = 0,
                    ComponentType = ComponentType.ReadWrite<CharacterControllerComponentData>(),
                    ComponentSize = UnsafeUtility.SizeOf<CharacterControllerComponentData>(),
                    SnapshotSize = UnsafeUtility.SizeOf<Snapshot>(),
                    ChangeMaskBits = ChangeMaskBits,
                    SendMask = GhostComponentSerializer.SendMask.Interpolated | GhostComponentSerializer.SendMask.Predicted,
                    SendToOwner = SendToOwnerType.All,
                    SendForChildEntities = 1,
                    VariantHash = 0,
                    CopyToSnapshot =
                        new PortableFunctionPointer<GhostComponentSerializer.CopyToFromSnapshotDelegate>(CopyToSnapshot),
                    CopyFromSnapshot =
                        new PortableFunctionPointer<GhostComponentSerializer.CopyToFromSnapshotDelegate>(CopyFromSnapshot),
                    RestoreFromBackup =
                        new PortableFunctionPointer<GhostComponentSerializer.RestoreFromBackupDelegate>(RestoreFromBackup),
                    PredictDelta = new PortableFunctionPointer<GhostComponentSerializer.PredictDeltaDelegate>(PredictDelta),
                    CalculateChangeMask =
                        new PortableFunctionPointer<GhostComponentSerializer.CalculateChangeMaskDelegate>(
                            CalculateChangeMask),
                    Serialize = new PortableFunctionPointer<GhostComponentSerializer.SerializeDelegate>(Serialize),
                    Deserialize = new PortableFunctionPointer<GhostComponentSerializer.DeserializeDelegate>(Deserialize),
                    #if UNITY_EDITOR || DEVELOPMENT_BUILD
                    ReportPredictionErrors = new PortableFunctionPointer<GhostComponentSerializer.ReportPredictionErrorsDelegate>(ReportPredictionErrors),
                    #endif
                };
                #if UNITY_EDITOR || DEVELOPMENT_BUILD
                s_State.NumPredictionErrorNames = GetPredictionErrorNames(ref s_State.PredictionErrorNames);
                #endif
                s_StateInitialized = true;
            }
            return s_State;
        }
        private static bool s_StateInitialized;
        private static GhostComponentSerializer.State s_State;
        public static GhostComponentSerializer.State State => GetState();
        public struct Snapshot
        {
            public float Gravity_x;
            public float Gravity_y;
            public float Gravity_z;
            public float MovementSpeed;
            public float MaxMovementSpeed;
            public float RotationSpeed;
            public float JumpUpwardsSpeed;
            public float MaxSlope;
            public int MaxIterations;
            public float CharacterMass;
            public float SkinWidth;
            public float ContactTolerance;
            public uint AffectsPhysicsBodies;
            public uint RaiseCollisionEvents;
            public uint RaiseTriggerEvents;
        }
        public const int ChangeMaskBits = 13;
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.CopyToFromSnapshotDelegate))]
        private static void CopyToSnapshot(IntPtr stateData, IntPtr snapshotData, int snapshotOffset, int snapshotStride, IntPtr componentData, int componentStride, int count)
        {
            for (int i = 0; i < count; ++i)
            {
                ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData, snapshotOffset + snapshotStride*i);
                ref var component = ref GhostComponentSerializer.TypeCast<CharacterControllerComponentData>(componentData, componentStride*i);
                ref var serializerState = ref GhostComponentSerializer.TypeCast<GhostSerializerState>(stateData, 0);
                snapshot.Gravity_x = component.Gravity.x;
                snapshot.Gravity_y = component.Gravity.y;
                snapshot.Gravity_z = component.Gravity.z;
                snapshot.MovementSpeed = component.MovementSpeed;
                snapshot.MaxMovementSpeed = component.MaxMovementSpeed;
                snapshot.RotationSpeed = component.RotationSpeed;
                snapshot.JumpUpwardsSpeed = component.JumpUpwardsSpeed;
                snapshot.MaxSlope = component.MaxSlope;
                snapshot.MaxIterations = (int) component.MaxIterations;
                snapshot.CharacterMass = component.CharacterMass;
                snapshot.SkinWidth = component.SkinWidth;
                snapshot.ContactTolerance = component.ContactTolerance;
                snapshot.AffectsPhysicsBodies = (uint)component.AffectsPhysicsBodies;
                snapshot.RaiseCollisionEvents = (uint)component.RaiseCollisionEvents;
                snapshot.RaiseTriggerEvents = (uint)component.RaiseTriggerEvents;
            }
        }
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.CopyToFromSnapshotDelegate))]
        private static void CopyFromSnapshot(IntPtr stateData, IntPtr snapshotData, int snapshotOffset, int snapshotStride, IntPtr componentData, int componentStride, int count)
        {
            for (int i = 0; i < count; ++i)
            {
                var deserializerState = GhostComponentSerializer.TypeCast<GhostDeserializerState>(stateData, 0);
                ref var snapshotInterpolationData = ref GhostComponentSerializer.TypeCast<SnapshotData.DataAtTick>(snapshotData, snapshotStride*i);
                ref var snapshotBefore = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotInterpolationData.SnapshotBefore, snapshotOffset);
                ref var snapshotAfter = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotInterpolationData.SnapshotAfter, snapshotOffset);
                //Compute the required owner mask for the components and buffers by retrievieng the ghost owner id from the data for the current tick.
                if (snapshotInterpolationData.GhostOwner > 0)
                {
                    var requiredOwnerMask = snapshotInterpolationData.GhostOwner == deserializerState.GhostOwner
                        ? SendToOwnerType.SendToOwner
                        : SendToOwnerType.SendToNonOwner;
                    if ((deserializerState.SendToOwner & requiredOwnerMask) == 0)
                        continue;
                }
                deserializerState.SnapshotTick = snapshotInterpolationData.Tick;
                float snapshotInterpolationFactorRaw = snapshotInterpolationData.InterpolationFactor;
                float snapshotInterpolationFactor = snapshotInterpolationFactorRaw;
                ref var component = ref GhostComponentSerializer.TypeCast<CharacterControllerComponentData>(componentData, componentStride*i);
                component.Gravity = new float3(snapshotBefore.Gravity_x, snapshotBefore.Gravity_y, snapshotBefore.Gravity_z);
                component.MovementSpeed = snapshotBefore.MovementSpeed;
                component.MaxMovementSpeed = snapshotBefore.MaxMovementSpeed;
                component.RotationSpeed = snapshotBefore.RotationSpeed;
                component.JumpUpwardsSpeed = snapshotBefore.JumpUpwardsSpeed;
                component.MaxSlope = snapshotBefore.MaxSlope;
                component.MaxIterations = (int) snapshotBefore.MaxIterations;
                component.CharacterMass = snapshotBefore.CharacterMass;
                component.SkinWidth = snapshotBefore.SkinWidth;
                component.ContactTolerance = snapshotBefore.ContactTolerance;
                component.AffectsPhysicsBodies = (byte) snapshotBefore.AffectsPhysicsBodies;
                component.RaiseCollisionEvents = (byte) snapshotBefore.RaiseCollisionEvents;
                component.RaiseTriggerEvents = (byte) snapshotBefore.RaiseTriggerEvents;

            }
        }


        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.RestoreFromBackupDelegate))]
        private static void RestoreFromBackup(IntPtr componentData, IntPtr backupData)
        {
            ref var component = ref GhostComponentSerializer.TypeCast<CharacterControllerComponentData>(componentData, 0);
            ref var backup = ref GhostComponentSerializer.TypeCast<CharacterControllerComponentData>(backupData, 0);
            component.Gravity.x = backup.Gravity.x;
            component.Gravity.y = backup.Gravity.y;
            component.Gravity.z = backup.Gravity.z;
            component.MovementSpeed = backup.MovementSpeed;
            component.MaxMovementSpeed = backup.MaxMovementSpeed;
            component.RotationSpeed = backup.RotationSpeed;
            component.JumpUpwardsSpeed = backup.JumpUpwardsSpeed;
            component.MaxSlope = backup.MaxSlope;
            component.MaxIterations = backup.MaxIterations;
            component.CharacterMass = backup.CharacterMass;
            component.SkinWidth = backup.SkinWidth;
            component.ContactTolerance = backup.ContactTolerance;
            component.AffectsPhysicsBodies = backup.AffectsPhysicsBodies;
            component.RaiseCollisionEvents = backup.RaiseCollisionEvents;
            component.RaiseTriggerEvents = backup.RaiseTriggerEvents;
        }

        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.PredictDeltaDelegate))]
        private static void PredictDelta(IntPtr snapshotData, IntPtr baseline1Data, IntPtr baseline2Data, ref GhostDeltaPredictor predictor)
        {
            ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData);
            ref var baseline1 = ref GhostComponentSerializer.TypeCast<Snapshot>(baseline1Data);
            ref var baseline2 = ref GhostComponentSerializer.TypeCast<Snapshot>(baseline2Data);
            snapshot.MaxIterations = predictor.PredictInt(snapshot.MaxIterations, baseline1.MaxIterations, baseline2.MaxIterations);
            snapshot.AffectsPhysicsBodies = (uint)predictor.PredictInt((int)snapshot.AffectsPhysicsBodies, (int)baseline1.AffectsPhysicsBodies, (int)baseline2.AffectsPhysicsBodies);
            snapshot.RaiseCollisionEvents = (uint)predictor.PredictInt((int)snapshot.RaiseCollisionEvents, (int)baseline1.RaiseCollisionEvents, (int)baseline2.RaiseCollisionEvents);
            snapshot.RaiseTriggerEvents = (uint)predictor.PredictInt((int)snapshot.RaiseTriggerEvents, (int)baseline1.RaiseTriggerEvents, (int)baseline2.RaiseTriggerEvents);
        }
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.CalculateChangeMaskDelegate))]
        private static void CalculateChangeMask(IntPtr snapshotData, IntPtr baselineData, IntPtr bits, int startOffset)
        {
            ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData);
            ref var baseline = ref GhostComponentSerializer.TypeCast<Snapshot>(baselineData);
            uint changeMask;
            changeMask = (snapshot.Gravity_x != baseline.Gravity_x) ? 1u : 0;
            changeMask |= (snapshot.Gravity_y != baseline.Gravity_y) ? (1u<<0) : 0;
            changeMask |= (snapshot.Gravity_z != baseline.Gravity_z) ? (1u<<0) : 0;
            changeMask |= (snapshot.MovementSpeed != baseline.MovementSpeed) ? (1u<<1) : 0;
            changeMask |= (snapshot.MaxMovementSpeed != baseline.MaxMovementSpeed) ? (1u<<2) : 0;
            changeMask |= (snapshot.RotationSpeed != baseline.RotationSpeed) ? (1u<<3) : 0;
            changeMask |= (snapshot.JumpUpwardsSpeed != baseline.JumpUpwardsSpeed) ? (1u<<4) : 0;
            changeMask |= (snapshot.MaxSlope != baseline.MaxSlope) ? (1u<<5) : 0;
            changeMask |= (snapshot.MaxIterations != baseline.MaxIterations) ? (1u<<6) : 0;
            changeMask |= (snapshot.CharacterMass != baseline.CharacterMass) ? (1u<<7) : 0;
            changeMask |= (snapshot.SkinWidth != baseline.SkinWidth) ? (1u<<8) : 0;
            changeMask |= (snapshot.ContactTolerance != baseline.ContactTolerance) ? (1u<<9) : 0;
            changeMask |= (snapshot.AffectsPhysicsBodies != baseline.AffectsPhysicsBodies) ? (1u<<10) : 0;
            changeMask |= (snapshot.RaiseCollisionEvents != baseline.RaiseCollisionEvents) ? (1u<<11) : 0;
            changeMask |= (snapshot.RaiseTriggerEvents != baseline.RaiseTriggerEvents) ? (1u<<12) : 0;
            GhostComponentSerializer.CopyToChangeMask(bits, changeMask, startOffset, 13);
        }
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.SerializeDelegate))]
        private static void Serialize(IntPtr snapshotData, IntPtr baselineData, ref DataStreamWriter writer, ref NetworkCompressionModel compressionModel, IntPtr changeMaskData, int startOffset)
        {
            ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData);
            ref var baseline = ref GhostComponentSerializer.TypeCast<Snapshot>(baselineData);
            uint changeMask = GhostComponentSerializer.CopyFromChangeMask(changeMaskData, startOffset, ChangeMaskBits);
            if ((changeMask & (1 << 0)) != 0)
                writer.WritePackedFloatDelta(snapshot.Gravity_x, baseline.Gravity_x, compressionModel);
            if ((changeMask & (1 << 0)) != 0)
                writer.WritePackedFloatDelta(snapshot.Gravity_y, baseline.Gravity_y, compressionModel);
            if ((changeMask & (1 << 0)) != 0)
                writer.WritePackedFloatDelta(snapshot.Gravity_z, baseline.Gravity_z, compressionModel);
            if ((changeMask & (1 << 1)) != 0)
                writer.WritePackedFloatDelta(snapshot.MovementSpeed, baseline.MovementSpeed, compressionModel);
            if ((changeMask & (1 << 2)) != 0)
                writer.WritePackedFloatDelta(snapshot.MaxMovementSpeed, baseline.MaxMovementSpeed, compressionModel);
            if ((changeMask & (1 << 3)) != 0)
                writer.WritePackedFloatDelta(snapshot.RotationSpeed, baseline.RotationSpeed, compressionModel);
            if ((changeMask & (1 << 4)) != 0)
                writer.WritePackedFloatDelta(snapshot.JumpUpwardsSpeed, baseline.JumpUpwardsSpeed, compressionModel);
            if ((changeMask & (1 << 5)) != 0)
                writer.WritePackedFloatDelta(snapshot.MaxSlope, baseline.MaxSlope, compressionModel);
            if ((changeMask & (1 << 6)) != 0)
                writer.WritePackedIntDelta(snapshot.MaxIterations, baseline.MaxIterations, compressionModel);
            if ((changeMask & (1 << 7)) != 0)
                writer.WritePackedFloatDelta(snapshot.CharacterMass, baseline.CharacterMass, compressionModel);
            if ((changeMask & (1 << 8)) != 0)
                writer.WritePackedFloatDelta(snapshot.SkinWidth, baseline.SkinWidth, compressionModel);
            if ((changeMask & (1 << 9)) != 0)
                writer.WritePackedFloatDelta(snapshot.ContactTolerance, baseline.ContactTolerance, compressionModel);
            if ((changeMask & (1 << 10)) != 0)
                writer.WritePackedUIntDelta(snapshot.AffectsPhysicsBodies, baseline.AffectsPhysicsBodies, compressionModel);
            if ((changeMask & (1 << 11)) != 0)
                writer.WritePackedUIntDelta(snapshot.RaiseCollisionEvents, baseline.RaiseCollisionEvents, compressionModel);
            if ((changeMask & (1 << 12)) != 0)
                writer.WritePackedUIntDelta(snapshot.RaiseTriggerEvents, baseline.RaiseTriggerEvents, compressionModel);
        }
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.DeserializeDelegate))]
        private static void Deserialize(IntPtr snapshotData, IntPtr baselineData, ref DataStreamReader reader, ref NetworkCompressionModel compressionModel, IntPtr changeMaskData, int startOffset)
        {
            ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData);
            ref var baseline = ref GhostComponentSerializer.TypeCast<Snapshot>(baselineData);
            uint changeMask = GhostComponentSerializer.CopyFromChangeMask(changeMaskData, startOffset, ChangeMaskBits);
            if ((changeMask & (1 << 0)) != 0)
                snapshot.Gravity_x = reader.ReadPackedFloatDelta(baseline.Gravity_x, compressionModel);
            else
                snapshot.Gravity_x = baseline.Gravity_x;
            if ((changeMask & (1 << 0)) != 0)
                snapshot.Gravity_y = reader.ReadPackedFloatDelta(baseline.Gravity_y, compressionModel);
            else
                snapshot.Gravity_y = baseline.Gravity_y;
            if ((changeMask & (1 << 0)) != 0)
                snapshot.Gravity_z = reader.ReadPackedFloatDelta(baseline.Gravity_z, compressionModel);
            else
                snapshot.Gravity_z = baseline.Gravity_z;
            if ((changeMask & (1 << 1)) != 0)
                snapshot.MovementSpeed = reader.ReadPackedFloatDelta(baseline.MovementSpeed, compressionModel);
            else
                snapshot.MovementSpeed = baseline.MovementSpeed;
            if ((changeMask & (1 << 2)) != 0)
                snapshot.MaxMovementSpeed = reader.ReadPackedFloatDelta(baseline.MaxMovementSpeed, compressionModel);
            else
                snapshot.MaxMovementSpeed = baseline.MaxMovementSpeed;
            if ((changeMask & (1 << 3)) != 0)
                snapshot.RotationSpeed = reader.ReadPackedFloatDelta(baseline.RotationSpeed, compressionModel);
            else
                snapshot.RotationSpeed = baseline.RotationSpeed;
            if ((changeMask & (1 << 4)) != 0)
                snapshot.JumpUpwardsSpeed = reader.ReadPackedFloatDelta(baseline.JumpUpwardsSpeed, compressionModel);
            else
                snapshot.JumpUpwardsSpeed = baseline.JumpUpwardsSpeed;
            if ((changeMask & (1 << 5)) != 0)
                snapshot.MaxSlope = reader.ReadPackedFloatDelta(baseline.MaxSlope, compressionModel);
            else
                snapshot.MaxSlope = baseline.MaxSlope;
            if ((changeMask & (1 << 6)) != 0)
                snapshot.MaxIterations = reader.ReadPackedIntDelta(baseline.MaxIterations, compressionModel);
            else
                snapshot.MaxIterations = baseline.MaxIterations;
            if ((changeMask & (1 << 7)) != 0)
                snapshot.CharacterMass = reader.ReadPackedFloatDelta(baseline.CharacterMass, compressionModel);
            else
                snapshot.CharacterMass = baseline.CharacterMass;
            if ((changeMask & (1 << 8)) != 0)
                snapshot.SkinWidth = reader.ReadPackedFloatDelta(baseline.SkinWidth, compressionModel);
            else
                snapshot.SkinWidth = baseline.SkinWidth;
            if ((changeMask & (1 << 9)) != 0)
                snapshot.ContactTolerance = reader.ReadPackedFloatDelta(baseline.ContactTolerance, compressionModel);
            else
                snapshot.ContactTolerance = baseline.ContactTolerance;
            if ((changeMask & (1 << 10)) != 0)
                snapshot.AffectsPhysicsBodies = reader.ReadPackedUIntDelta(baseline.AffectsPhysicsBodies, compressionModel);
            else
                snapshot.AffectsPhysicsBodies = baseline.AffectsPhysicsBodies;
            if ((changeMask & (1 << 11)) != 0)
                snapshot.RaiseCollisionEvents = reader.ReadPackedUIntDelta(baseline.RaiseCollisionEvents, compressionModel);
            else
                snapshot.RaiseCollisionEvents = baseline.RaiseCollisionEvents;
            if ((changeMask & (1 << 12)) != 0)
                snapshot.RaiseTriggerEvents = reader.ReadPackedUIntDelta(baseline.RaiseTriggerEvents, compressionModel);
            else
                snapshot.RaiseTriggerEvents = baseline.RaiseTriggerEvents;
        }
        #if UNITY_EDITOR || DEVELOPMENT_BUILD
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.ReportPredictionErrorsDelegate))]
        private static void ReportPredictionErrors(IntPtr componentData, IntPtr backupData, ref UnsafeList<float> errors)
        {
            ref var component = ref GhostComponentSerializer.TypeCast<CharacterControllerComponentData>(componentData, 0);
            ref var backup = ref GhostComponentSerializer.TypeCast<CharacterControllerComponentData>(backupData, 0);
            int errorIndex = 0;
            errors[errorIndex] = math.max(errors[errorIndex], math.distance(component.Gravity, backup.Gravity));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.MovementSpeed - backup.MovementSpeed));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.MaxMovementSpeed - backup.MaxMovementSpeed));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.RotationSpeed - backup.RotationSpeed));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.JumpUpwardsSpeed - backup.JumpUpwardsSpeed));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.MaxSlope - backup.MaxSlope));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.MaxIterations - backup.MaxIterations));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.CharacterMass - backup.CharacterMass));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.SkinWidth - backup.SkinWidth));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.ContactTolerance - backup.ContactTolerance));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex],
                (component.AffectsPhysicsBodies > backup.AffectsPhysicsBodies) ?
                (component.AffectsPhysicsBodies - backup.AffectsPhysicsBodies) :
                (backup.AffectsPhysicsBodies - component.AffectsPhysicsBodies));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex],
                (component.RaiseCollisionEvents > backup.RaiseCollisionEvents) ?
                (component.RaiseCollisionEvents - backup.RaiseCollisionEvents) :
                (backup.RaiseCollisionEvents - component.RaiseCollisionEvents));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex],
                (component.RaiseTriggerEvents > backup.RaiseTriggerEvents) ?
                (component.RaiseTriggerEvents - backup.RaiseTriggerEvents) :
                (backup.RaiseTriggerEvents - component.RaiseTriggerEvents));
            ++errorIndex;
        }
        private static int GetPredictionErrorNames(ref FixedString512 names)
        {
            int nameCount = 0;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("Gravity"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("MovementSpeed"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("MaxMovementSpeed"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("RotationSpeed"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("JumpUpwardsSpeed"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("MaxSlope"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("MaxIterations"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("CharacterMass"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("SkinWidth"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("ContactTolerance"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("AffectsPhysicsBodies"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("RaiseCollisionEvents"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("RaiseTriggerEvents"));
            ++nameCount;
            return nameCount;
        }
        #endif
    }
}
