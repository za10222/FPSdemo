//THIS FILE IS AUTOGENERATED BY GHOSTCOMPILER. DON'T MODIFY OR ALTER.
using System;
using AOT;
using Unity.Burst;
using Unity.Networking.Transport;
using Unity.NetCode.LowLevel.Unsafe;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Entities;
using Unity.Collections;
using Unity.NetCode;
using Unity.Transforms;
using Unity.Mathematics;

namespace Assembly_CSharp.Generated
{
    [BurstCompile]
    public struct FPSdemoGunManager_ShootEventDataGhostComponentSerializer
    {
        static GhostComponentSerializer.State GetState()
        {
            // This needs to be lazy initialized because otherwise there is a depenency on the static initialization order which breaks il2cpp builds due to TYpeManager not being initialized yet
            if (!s_StateInitialized)
            {
                s_State = new GhostComponentSerializer.State
                {
                    GhostFieldsHash = 15333542285372593529,
                    ExcludeFromComponentCollectionHash = 0,
                    ComponentType = ComponentType.ReadWrite<FPSdemo.GunManager.ShootEventData>(),
                    ComponentSize = UnsafeUtility.SizeOf<FPSdemo.GunManager.ShootEventData>(),
                    SnapshotSize = UnsafeUtility.SizeOf<Snapshot>(),
                    ChangeMaskBits = ChangeMaskBits,
                    SendMask = GhostComponentSerializer.SendMask.Interpolated | GhostComponentSerializer.SendMask.Predicted,
                    SendToOwner = SendToOwnerType.All,
                    SendForChildEntities = 1,
                    VariantHash = 0,
                    CopyToSnapshot =
                        new PortableFunctionPointer<GhostComponentSerializer.CopyToFromSnapshotDelegate>(CopyToSnapshot),
                    CopyFromSnapshot =
                        new PortableFunctionPointer<GhostComponentSerializer.CopyToFromSnapshotDelegate>(CopyFromSnapshot),
                    RestoreFromBackup =
                        new PortableFunctionPointer<GhostComponentSerializer.RestoreFromBackupDelegate>(RestoreFromBackup),
                    PredictDelta = new PortableFunctionPointer<GhostComponentSerializer.PredictDeltaDelegate>(PredictDelta),
                    CalculateChangeMask =
                        new PortableFunctionPointer<GhostComponentSerializer.CalculateChangeMaskDelegate>(
                            CalculateChangeMask),
                    Serialize = new PortableFunctionPointer<GhostComponentSerializer.SerializeDelegate>(Serialize),
                    Deserialize = new PortableFunctionPointer<GhostComponentSerializer.DeserializeDelegate>(Deserialize),
                    #if UNITY_EDITOR || DEVELOPMENT_BUILD
                    ReportPredictionErrors = new PortableFunctionPointer<GhostComponentSerializer.ReportPredictionErrorsDelegate>(ReportPredictionErrors),
                    #endif
                };
                #if UNITY_EDITOR || DEVELOPMENT_BUILD
                s_State.NumPredictionErrorNames = GetPredictionErrorNames(ref s_State.PredictionErrorNames);
                #endif
                s_StateInitialized = true;
            }
            return s_State;
        }
        private static bool s_StateInitialized;
        private static GhostComponentSerializer.State s_State;
        public static GhostComponentSerializer.State State => GetState();
        public struct Snapshot
        {
            public float gunBaseData_shootgap;
            public int gunBaseData_gunTypeIndex;
            public float gunBaseData_ballisticVelocity;
            public int owner;
            public int translation_Value_x;
            public int translation_Value_y;
            public int translation_Value_z;
            public int rotation_ValueX;
            public int rotation_ValueY;
            public int rotation_ValueZ;
            public int rotation_ValueW;
            public uint ishandle;
            public float lifetime;
            public float hitPosition_x;
            public float hitPosition_y;
            public float hitPosition_z;
            public float hitSurfaceNormal_x;
            public float hitSurfaceNormal_y;
            public float hitSurfaceNormal_z;
            public uint spawntick;
        }
        public const int ChangeMaskBits = 11;
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.CopyToFromSnapshotDelegate))]
        private static void CopyToSnapshot(IntPtr stateData, IntPtr snapshotData, int snapshotOffset, int snapshotStride, IntPtr componentData, int componentStride, int count)
        {
            for (int i = 0; i < count; ++i)
            {
                ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData, snapshotOffset + snapshotStride*i);
                ref var component = ref GhostComponentSerializer.TypeCast<FPSdemo.GunManager.ShootEventData>(componentData, componentStride*i);
                ref var serializerState = ref GhostComponentSerializer.TypeCast<GhostSerializerState>(stateData, 0);
                snapshot.gunBaseData_shootgap = component.gunBaseData.shootgap;
                snapshot.gunBaseData_gunTypeIndex = (int) component.gunBaseData.gunTypeIndex;
                snapshot.gunBaseData_ballisticVelocity = component.gunBaseData.ballisticVelocity;
                snapshot.owner = (int) component.owner;
                snapshot.translation_Value_x = (int) math.round(component.translation.Value.x * 100);
                snapshot.translation_Value_y = (int) math.round(component.translation.Value.y * 100);
                snapshot.translation_Value_z = (int) math.round(component.translation.Value.z * 100);
                snapshot.rotation_ValueX = (int)math.round(component.rotation.Value.value.x * 1000);
                snapshot.rotation_ValueY = (int)math.round(component.rotation.Value.value.y * 1000);
                snapshot.rotation_ValueZ = (int)math.round(component.rotation.Value.value.z * 1000);
                snapshot.rotation_ValueW = (int)math.round(component.rotation.Value.value.w * 1000);
                snapshot.ishandle = component.ishandle?1u:0;
                snapshot.lifetime = component.lifetime;
                snapshot.hitPosition_x = component.hitPosition.x;
                snapshot.hitPosition_y = component.hitPosition.y;
                snapshot.hitPosition_z = component.hitPosition.z;
                snapshot.hitSurfaceNormal_x = component.hitSurfaceNormal.x;
                snapshot.hitSurfaceNormal_y = component.hitSurfaceNormal.y;
                snapshot.hitSurfaceNormal_z = component.hitSurfaceNormal.z;
                snapshot.spawntick = (uint)component.spawntick;
            }
        }
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.CopyToFromSnapshotDelegate))]
        private static void CopyFromSnapshot(IntPtr stateData, IntPtr snapshotData, int snapshotOffset, int snapshotStride, IntPtr componentData, int componentStride, int count)
        {
            for (int i = 0; i < count; ++i)
            {
                var deserializerState = GhostComponentSerializer.TypeCast<GhostDeserializerState>(stateData, 0);
                ref var snapshotInterpolationData = ref GhostComponentSerializer.TypeCast<SnapshotData.DataAtTick>(snapshotData, snapshotStride*i);
                ref var snapshotBefore = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotInterpolationData.SnapshotBefore, snapshotOffset);
                ref var snapshotAfter = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotInterpolationData.SnapshotAfter, snapshotOffset);
                //Compute the required owner mask for the components and buffers by retrievieng the ghost owner id from the data for the current tick.
                if (snapshotInterpolationData.GhostOwner > 0)
                {
                    var requiredOwnerMask = snapshotInterpolationData.GhostOwner == deserializerState.GhostOwner
                        ? SendToOwnerType.SendToOwner
                        : SendToOwnerType.SendToNonOwner;
                    if ((deserializerState.SendToOwner & requiredOwnerMask) == 0)
                        continue;
                }
                deserializerState.SnapshotTick = snapshotInterpolationData.Tick;
                float snapshotInterpolationFactorRaw = snapshotInterpolationData.InterpolationFactor;
                float snapshotInterpolationFactor = snapshotInterpolationFactorRaw;
                ref var component = ref GhostComponentSerializer.TypeCast<FPSdemo.GunManager.ShootEventData>(componentData, componentStride*i);
                component.gunBaseData.shootgap = snapshotBefore.gunBaseData_shootgap;
                component.gunBaseData.gunTypeIndex = (int) snapshotBefore.gunBaseData_gunTypeIndex;
                component.gunBaseData.ballisticVelocity = snapshotBefore.gunBaseData_ballisticVelocity;
                component.owner = (int) snapshotBefore.owner;
                snapshotInterpolationFactor = snapshotInterpolationFactorRaw;
                var translation_Value_Before = new float3(snapshotBefore.translation_Value_x * 0.01f, snapshotBefore.translation_Value_y * 0.01f, snapshotBefore.translation_Value_z * 0.01f);
                var translation_Value_After = new float3(snapshotAfter.translation_Value_x * 0.01f, snapshotAfter.translation_Value_y * 0.01f, snapshotAfter.translation_Value_z * 0.01f);
                component.translation.Value = math.lerp(translation_Value_Before, translation_Value_After, snapshotInterpolationFactor);
                snapshotInterpolationFactor = snapshotInterpolationFactorRaw;
                var rotation_Value_Before = math.normalize(new quaternion(snapshotBefore.rotation_ValueX * 0.001f, snapshotBefore.rotation_ValueY * 0.001f, snapshotBefore.rotation_ValueZ * 0.001f, snapshotBefore.rotation_ValueW * 0.001f));
                var rotation_Value_After = math.normalize(new quaternion(snapshotAfter.rotation_ValueX * 0.001f, snapshotAfter.rotation_ValueY * 0.001f, snapshotAfter.rotation_ValueZ * 0.001f, snapshotAfter.rotation_ValueW * 0.001f));
                component.rotation.Value = math.slerp(rotation_Value_Before,
                    rotation_Value_After, snapshotInterpolationFactor);
                component.ishandle = snapshotBefore.ishandle != 0;
                component.lifetime = snapshotBefore.lifetime;
                component.hitPosition = new float3(snapshotBefore.hitPosition_x, snapshotBefore.hitPosition_y, snapshotBefore.hitPosition_z);
                component.hitSurfaceNormal = new float3(snapshotBefore.hitSurfaceNormal_x, snapshotBefore.hitSurfaceNormal_y, snapshotBefore.hitSurfaceNormal_z);
                component.spawntick = (uint) snapshotBefore.spawntick;

            }
        }


        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.RestoreFromBackupDelegate))]
        private static void RestoreFromBackup(IntPtr componentData, IntPtr backupData)
        {
            ref var component = ref GhostComponentSerializer.TypeCast<FPSdemo.GunManager.ShootEventData>(componentData, 0);
            ref var backup = ref GhostComponentSerializer.TypeCast<FPSdemo.GunManager.ShootEventData>(backupData, 0);
            component.gunBaseData.shootgap = backup.gunBaseData.shootgap;
            component.gunBaseData.gunTypeIndex = backup.gunBaseData.gunTypeIndex;
            component.gunBaseData.ballisticVelocity = backup.gunBaseData.ballisticVelocity;
            component.owner = backup.owner;
            component.translation.Value.x = backup.translation.Value.x;
            component.translation.Value.y = backup.translation.Value.y;
            component.translation.Value.z = backup.translation.Value.z;
            component.rotation.Value = backup.rotation.Value;
            component.ishandle = backup.ishandle;
            component.lifetime = backup.lifetime;
            component.hitPosition.x = backup.hitPosition.x;
            component.hitPosition.y = backup.hitPosition.y;
            component.hitPosition.z = backup.hitPosition.z;
            component.hitSurfaceNormal.x = backup.hitSurfaceNormal.x;
            component.hitSurfaceNormal.y = backup.hitSurfaceNormal.y;
            component.hitSurfaceNormal.z = backup.hitSurfaceNormal.z;
            component.spawntick = backup.spawntick;
        }

        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.PredictDeltaDelegate))]
        private static void PredictDelta(IntPtr snapshotData, IntPtr baseline1Data, IntPtr baseline2Data, ref GhostDeltaPredictor predictor)
        {
            ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData);
            ref var baseline1 = ref GhostComponentSerializer.TypeCast<Snapshot>(baseline1Data);
            ref var baseline2 = ref GhostComponentSerializer.TypeCast<Snapshot>(baseline2Data);
            snapshot.gunBaseData_gunTypeIndex = predictor.PredictInt(snapshot.gunBaseData_gunTypeIndex, baseline1.gunBaseData_gunTypeIndex, baseline2.gunBaseData_gunTypeIndex);
            snapshot.owner = predictor.PredictInt(snapshot.owner, baseline1.owner, baseline2.owner);
            snapshot.translation_Value_x = predictor.PredictInt(snapshot.translation_Value_x, baseline1.translation_Value_x, baseline2.translation_Value_x);
            snapshot.translation_Value_y = predictor.PredictInt(snapshot.translation_Value_y, baseline1.translation_Value_y, baseline2.translation_Value_y);
            snapshot.translation_Value_z = predictor.PredictInt(snapshot.translation_Value_z, baseline1.translation_Value_z, baseline2.translation_Value_z);
            snapshot.rotation_ValueX = predictor.PredictInt(snapshot.rotation_ValueX, baseline1.rotation_ValueX, baseline2.rotation_ValueX);
            snapshot.rotation_ValueY = predictor.PredictInt(snapshot.rotation_ValueY, baseline1.rotation_ValueY, baseline2.rotation_ValueY);
            snapshot.rotation_ValueZ = predictor.PredictInt(snapshot.rotation_ValueZ, baseline1.rotation_ValueZ, baseline2.rotation_ValueZ);
            snapshot.rotation_ValueW = predictor.PredictInt(snapshot.rotation_ValueW, baseline1.rotation_ValueW, baseline2.rotation_ValueW);
            snapshot.ishandle = (uint)predictor.PredictInt((int)snapshot.ishandle, (int)baseline1.ishandle, (int)baseline2.ishandle);
            snapshot.spawntick = (uint)predictor.PredictInt((int)snapshot.spawntick, (int)baseline1.spawntick, (int)baseline2.spawntick);
        }
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.CalculateChangeMaskDelegate))]
        private static void CalculateChangeMask(IntPtr snapshotData, IntPtr baselineData, IntPtr bits, int startOffset)
        {
            ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData);
            ref var baseline = ref GhostComponentSerializer.TypeCast<Snapshot>(baselineData);
            uint changeMask;
            changeMask = (snapshot.gunBaseData_shootgap != baseline.gunBaseData_shootgap) ? 1u : 0;
            changeMask |= (snapshot.gunBaseData_gunTypeIndex != baseline.gunBaseData_gunTypeIndex) ? (1u<<1) : 0;
            changeMask |= (snapshot.gunBaseData_ballisticVelocity != baseline.gunBaseData_ballisticVelocity) ? (1u<<2) : 0;
            changeMask |= (snapshot.owner != baseline.owner) ? (1u<<3) : 0;
            changeMask |= (snapshot.translation_Value_x != baseline.translation_Value_x) ? (1u<<4) : 0;
            changeMask |= (snapshot.translation_Value_y != baseline.translation_Value_y) ? (1u<<4) : 0;
            changeMask |= (snapshot.translation_Value_z != baseline.translation_Value_z) ? (1u<<4) : 0;
            changeMask |= (snapshot.rotation_ValueX != baseline.rotation_ValueX ||
                        snapshot.rotation_ValueY != baseline.rotation_ValueY ||
                        snapshot.rotation_ValueZ != baseline.rotation_ValueZ ||
                        snapshot.rotation_ValueW != baseline.rotation_ValueW) ? (1u<<5) : 0;
            changeMask |= (snapshot.ishandle != baseline.ishandle) ? (1u<<6) : 0;
            changeMask |= (snapshot.lifetime != baseline.lifetime) ? (1u<<7) : 0;
            changeMask |= (snapshot.hitPosition_x != baseline.hitPosition_x) ? (1u<<8) : 0;
            changeMask |= (snapshot.hitPosition_y != baseline.hitPosition_y) ? (1u<<8) : 0;
            changeMask |= (snapshot.hitPosition_z != baseline.hitPosition_z) ? (1u<<8) : 0;
            changeMask |= (snapshot.hitSurfaceNormal_x != baseline.hitSurfaceNormal_x) ? (1u<<9) : 0;
            changeMask |= (snapshot.hitSurfaceNormal_y != baseline.hitSurfaceNormal_y) ? (1u<<9) : 0;
            changeMask |= (snapshot.hitSurfaceNormal_z != baseline.hitSurfaceNormal_z) ? (1u<<9) : 0;
            changeMask |= (snapshot.spawntick != baseline.spawntick) ? (1u<<10) : 0;
            GhostComponentSerializer.CopyToChangeMask(bits, changeMask, startOffset, 11);
        }
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.SerializeDelegate))]
        private static void Serialize(IntPtr snapshotData, IntPtr baselineData, ref DataStreamWriter writer, ref NetworkCompressionModel compressionModel, IntPtr changeMaskData, int startOffset)
        {
            ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData);
            ref var baseline = ref GhostComponentSerializer.TypeCast<Snapshot>(baselineData);
            uint changeMask = GhostComponentSerializer.CopyFromChangeMask(changeMaskData, startOffset, ChangeMaskBits);
            if ((changeMask & (1 << 0)) != 0)
                writer.WritePackedFloatDelta(snapshot.gunBaseData_shootgap, baseline.gunBaseData_shootgap, compressionModel);
            if ((changeMask & (1 << 1)) != 0)
                writer.WritePackedIntDelta(snapshot.gunBaseData_gunTypeIndex, baseline.gunBaseData_gunTypeIndex, compressionModel);
            if ((changeMask & (1 << 2)) != 0)
                writer.WritePackedFloatDelta(snapshot.gunBaseData_ballisticVelocity, baseline.gunBaseData_ballisticVelocity, compressionModel);
            if ((changeMask & (1 << 3)) != 0)
                writer.WritePackedIntDelta(snapshot.owner, baseline.owner, compressionModel);
            if ((changeMask & (1 << 4)) != 0)
                writer.WritePackedIntDelta(snapshot.translation_Value_x, baseline.translation_Value_x, compressionModel);
            if ((changeMask & (1 << 4)) != 0)
                writer.WritePackedIntDelta(snapshot.translation_Value_y, baseline.translation_Value_y, compressionModel);
            if ((changeMask & (1 << 4)) != 0)
                writer.WritePackedIntDelta(snapshot.translation_Value_z, baseline.translation_Value_z, compressionModel);
            if ((changeMask & (1 << 5)) != 0)
            {
                writer.WritePackedIntDelta(snapshot.rotation_ValueX, baseline.rotation_ValueX, compressionModel);
                writer.WritePackedIntDelta(snapshot.rotation_ValueY, baseline.rotation_ValueY, compressionModel);
                writer.WritePackedIntDelta(snapshot.rotation_ValueZ, baseline.rotation_ValueZ, compressionModel);
                writer.WritePackedIntDelta(snapshot.rotation_ValueW, baseline.rotation_ValueW, compressionModel);
            }
            if ((changeMask & (1 << 6)) != 0)
                writer.WritePackedUIntDelta(snapshot.ishandle, baseline.ishandle, compressionModel);
            if ((changeMask & (1 << 7)) != 0)
                writer.WritePackedFloatDelta(snapshot.lifetime, baseline.lifetime, compressionModel);
            if ((changeMask & (1 << 8)) != 0)
                writer.WritePackedFloatDelta(snapshot.hitPosition_x, baseline.hitPosition_x, compressionModel);
            if ((changeMask & (1 << 8)) != 0)
                writer.WritePackedFloatDelta(snapshot.hitPosition_y, baseline.hitPosition_y, compressionModel);
            if ((changeMask & (1 << 8)) != 0)
                writer.WritePackedFloatDelta(snapshot.hitPosition_z, baseline.hitPosition_z, compressionModel);
            if ((changeMask & (1 << 9)) != 0)
                writer.WritePackedFloatDelta(snapshot.hitSurfaceNormal_x, baseline.hitSurfaceNormal_x, compressionModel);
            if ((changeMask & (1 << 9)) != 0)
                writer.WritePackedFloatDelta(snapshot.hitSurfaceNormal_y, baseline.hitSurfaceNormal_y, compressionModel);
            if ((changeMask & (1 << 9)) != 0)
                writer.WritePackedFloatDelta(snapshot.hitSurfaceNormal_z, baseline.hitSurfaceNormal_z, compressionModel);
            if ((changeMask & (1 << 10)) != 0)
                writer.WritePackedUIntDelta(snapshot.spawntick, baseline.spawntick, compressionModel);
        }
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.DeserializeDelegate))]
        private static void Deserialize(IntPtr snapshotData, IntPtr baselineData, ref DataStreamReader reader, ref NetworkCompressionModel compressionModel, IntPtr changeMaskData, int startOffset)
        {
            ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData);
            ref var baseline = ref GhostComponentSerializer.TypeCast<Snapshot>(baselineData);
            uint changeMask = GhostComponentSerializer.CopyFromChangeMask(changeMaskData, startOffset, ChangeMaskBits);
            if ((changeMask & (1 << 0)) != 0)
                snapshot.gunBaseData_shootgap = reader.ReadPackedFloatDelta(baseline.gunBaseData_shootgap, compressionModel);
            else
                snapshot.gunBaseData_shootgap = baseline.gunBaseData_shootgap;
            if ((changeMask & (1 << 1)) != 0)
                snapshot.gunBaseData_gunTypeIndex = reader.ReadPackedIntDelta(baseline.gunBaseData_gunTypeIndex, compressionModel);
            else
                snapshot.gunBaseData_gunTypeIndex = baseline.gunBaseData_gunTypeIndex;
            if ((changeMask & (1 << 2)) != 0)
                snapshot.gunBaseData_ballisticVelocity = reader.ReadPackedFloatDelta(baseline.gunBaseData_ballisticVelocity, compressionModel);
            else
                snapshot.gunBaseData_ballisticVelocity = baseline.gunBaseData_ballisticVelocity;
            if ((changeMask & (1 << 3)) != 0)
                snapshot.owner = reader.ReadPackedIntDelta(baseline.owner, compressionModel);
            else
                snapshot.owner = baseline.owner;
            if ((changeMask & (1 << 4)) != 0)
                snapshot.translation_Value_x = reader.ReadPackedIntDelta(baseline.translation_Value_x, compressionModel);
            else
                snapshot.translation_Value_x = baseline.translation_Value_x;
            if ((changeMask & (1 << 4)) != 0)
                snapshot.translation_Value_y = reader.ReadPackedIntDelta(baseline.translation_Value_y, compressionModel);
            else
                snapshot.translation_Value_y = baseline.translation_Value_y;
            if ((changeMask & (1 << 4)) != 0)
                snapshot.translation_Value_z = reader.ReadPackedIntDelta(baseline.translation_Value_z, compressionModel);
            else
                snapshot.translation_Value_z = baseline.translation_Value_z;
            if ((changeMask & (1 << 5)) != 0)
            {
                snapshot.rotation_ValueX = reader.ReadPackedIntDelta(baseline.rotation_ValueX, compressionModel);
                snapshot.rotation_ValueY = reader.ReadPackedIntDelta(baseline.rotation_ValueY, compressionModel);
                snapshot.rotation_ValueZ = reader.ReadPackedIntDelta(baseline.rotation_ValueZ, compressionModel);
                snapshot.rotation_ValueW = reader.ReadPackedIntDelta(baseline.rotation_ValueW, compressionModel);
            }
            else
            {
                snapshot.rotation_ValueX = baseline.rotation_ValueX;
                snapshot.rotation_ValueY = baseline.rotation_ValueY;
                snapshot.rotation_ValueZ = baseline.rotation_ValueZ;
                snapshot.rotation_ValueW = baseline.rotation_ValueW;
            }
            if ((changeMask & (1 << 6)) != 0)
                snapshot.ishandle = reader.ReadPackedUIntDelta(baseline.ishandle, compressionModel);
            else
                snapshot.ishandle = baseline.ishandle;
            if ((changeMask & (1 << 7)) != 0)
                snapshot.lifetime = reader.ReadPackedFloatDelta(baseline.lifetime, compressionModel);
            else
                snapshot.lifetime = baseline.lifetime;
            if ((changeMask & (1 << 8)) != 0)
                snapshot.hitPosition_x = reader.ReadPackedFloatDelta(baseline.hitPosition_x, compressionModel);
            else
                snapshot.hitPosition_x = baseline.hitPosition_x;
            if ((changeMask & (1 << 8)) != 0)
                snapshot.hitPosition_y = reader.ReadPackedFloatDelta(baseline.hitPosition_y, compressionModel);
            else
                snapshot.hitPosition_y = baseline.hitPosition_y;
            if ((changeMask & (1 << 8)) != 0)
                snapshot.hitPosition_z = reader.ReadPackedFloatDelta(baseline.hitPosition_z, compressionModel);
            else
                snapshot.hitPosition_z = baseline.hitPosition_z;
            if ((changeMask & (1 << 9)) != 0)
                snapshot.hitSurfaceNormal_x = reader.ReadPackedFloatDelta(baseline.hitSurfaceNormal_x, compressionModel);
            else
                snapshot.hitSurfaceNormal_x = baseline.hitSurfaceNormal_x;
            if ((changeMask & (1 << 9)) != 0)
                snapshot.hitSurfaceNormal_y = reader.ReadPackedFloatDelta(baseline.hitSurfaceNormal_y, compressionModel);
            else
                snapshot.hitSurfaceNormal_y = baseline.hitSurfaceNormal_y;
            if ((changeMask & (1 << 9)) != 0)
                snapshot.hitSurfaceNormal_z = reader.ReadPackedFloatDelta(baseline.hitSurfaceNormal_z, compressionModel);
            else
                snapshot.hitSurfaceNormal_z = baseline.hitSurfaceNormal_z;
            if ((changeMask & (1 << 10)) != 0)
                snapshot.spawntick = reader.ReadPackedUIntDelta(baseline.spawntick, compressionModel);
            else
                snapshot.spawntick = baseline.spawntick;
        }
        #if UNITY_EDITOR || DEVELOPMENT_BUILD
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.ReportPredictionErrorsDelegate))]
        private static void ReportPredictionErrors(IntPtr componentData, IntPtr backupData, ref UnsafeList<float> errors)
        {
            ref var component = ref GhostComponentSerializer.TypeCast<FPSdemo.GunManager.ShootEventData>(componentData, 0);
            ref var backup = ref GhostComponentSerializer.TypeCast<FPSdemo.GunManager.ShootEventData>(backupData, 0);
            int errorIndex = 0;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.gunBaseData.shootgap - backup.gunBaseData.shootgap));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.gunBaseData.gunTypeIndex - backup.gunBaseData.gunTypeIndex));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.gunBaseData.ballisticVelocity - backup.gunBaseData.ballisticVelocity));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.owner - backup.owner));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.distance(component.translation.Value, backup.translation.Value));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.distance(component.rotation.Value.value, backup.rotation.Value.value));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], (component.ishandle != backup.ishandle) ? 1 : 0);
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.lifetime - backup.lifetime));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.distance(component.hitPosition, backup.hitPosition));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.distance(component.hitSurfaceNormal, backup.hitSurfaceNormal));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex],
                (component.spawntick > backup.spawntick) ?
                (component.spawntick - backup.spawntick) :
                (backup.spawntick - component.spawntick));
            ++errorIndex;
        }
        private static int GetPredictionErrorNames(ref FixedString512 names)
        {
            int nameCount = 0;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("gunBaseData.shootgap"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("gunBaseData.gunTypeIndex"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("gunBaseData.ballisticVelocity"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("owner"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("translation.Value"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("rotation.Value"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("ishandle"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("lifetime"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("hitPosition"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("hitSurfaceNormal"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("spawntick"));
            ++nameCount;
            return nameCount;
        }
        #endif
    }
}
